How I Used AI:

(1)

//
private void playBackgroundMusic(String filepath) {
        try {
            File musicFile = new File(filepath);
            AudioInputStream audioStream = AudioSystem.getAudioInputStream(
                    new BufferedInputStream(new FileInputStream(filepath))
            );

            backgroundMusic = AudioSystem.getClip();
            backgroundMusic.open(audioStream);
            backgroundMusic.loop(Clip.LOOP_CONTINUOUSLY); // Loop the music
            backgroundMusic.start();
        } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {
            System.out.println("Failed to load background music: " + e.getMessage());
        }
    }
 //


I used AI to help me add background music to my game. At first, I kept getting an IllegalArgumentException:
Audio data < 0 error when trying to load and play a .wav file.

Prompt: “I keep getting IllegalArgumentException: Audio data < 0 when trying to play background music in Java. How do I fix this?”

What I did: AI suggested using a BufferedInputStream when loading the audio file to prevent issues with reading the data.
I tested this approach and found that it worked better than my original code.

How AI Helped Me Learn:
It helped me understand how Java handles audio streams and why reading the file properly is important.
Instead of just copying the solution, I experimented with different ways of loading the file to make sureI fully understood how it worked.


(2)

//
public LevelTransitionPanel(JFrame frame, Runnable onFadeComplete) {
    this.onFadeComplete = onFadeComplete;
    setOpaque(false);
    setBounds(0, 0, 1200, 800);

    // Load pixel font
    try {
        File fontFile = new File("data/Fonts/victor-pixel.ttf");
        pixelFont = Font.createFont(Font.TRUETYPE_FONT, fontFile).deriveFont(50f);
    } catch (FontFormatException | IOException e) {
        System.out.println("Could not load pixel font. Falling back.");
        pixelFont = new Font("Monospaced", Font.BOLD, 48);
    }

    timer = new Timer(120, new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent e) {
            if (fadingIn) {
                alpha += 0.1f;
                if (alpha >= 1.5f) {
                    alpha = 1.5f;
                    fadingIn = false;
                    onFadeComplete.run(); // trigger the level switch here
                }
            } else {
                alpha -= 0.05f;
                if (alpha <= 0f) {
                    alpha = 0f;
                    timer.stop();
                    Container parent = getParent();
                    if (parent != null) parent.remove(LevelTransitionPanel.this);
                    parent.repaint();
                }
            }
            repaint();
        }
    });
    timer.start();
}
//

I used AI to help me implement a smooth level transition animation with fade-out/fade-in effects in my game.
I wanted the screen to fade to black when the player reached the win object, then load the next level and fade back in,
keeping the cat’s health and food count intact.

Prompt: “How can I implement a fade to black effect in Java Swing and transition between game levels?”

What I did: AI suggested using a JPanel with AlphaComposite to control transparency, and a javax.swing.Timer to update
the opacity over time. I used this advice to create the LevelTransitionPanel, which runs the fade effect and executes a
Runnable callback to switch levels once the screen is fully black.

How AI Helped Me Learn:
AI helped me understand how to animate visual transitions in Java using transparency and timing, something I hadn’t done before.
I also learned how to use JLayeredPane to overlay transition effects above the game view without interfering with gameplay elements.



(3)

//
@Override
public void beginContact(SensorEvent e) {
    if (e.getContactBody() instanceof Cat cat && !cat.isTeleporting()) {
        Vec2 catPos = cat.getPosition();
        float distToBottom = catPos.sub(bottomSensorBody.getPosition()).length();
        float distToTop = catPos.sub(topSensorBody.getPosition()).length();

        if (distToBottom < 1.5f) {
            cat.setPosition(topTeleportPosition);
            cat.setTeleporting(true);
        } else if (distToTop < 1.5f) {
            cat.setPosition(bottomTeleportPosition);
            cat.setTeleporting(true);
        }
    }
}
//
I used AI to help me make a ladder teleport system where the cat could climb up or down when touching either the
bottom or top of the ladder. I wasn’t sure how to tell which side the player touched.

Prompt:
"How can I teleport a player between two points when they touch the top or bottom of a ladder in Java?"

What I did:
AI suggested calculating the distance between the player and the sensors at the top and bottom. I adapted the idea
and added a isTeleporting flag to the Cat class to make sure the cat doesn't teleport multiple times by accident.

How AI Helped Me Learn:
It taught me an easy way to use distance checking for interactions and made me think about designing cleaner collision systems.



(4)

//
public static void saveGame(int level, int score, int lives, float catX, float catY, File file) {
    try (PrintWriter writer = new PrintWriter(file)) {
        writer.println("# Save Timestamp: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
        writer.println(level);
        writer.println(score);
        writer.println(lives);
        writer.println(catX);
        writer.println(catY);
    } catch (IOException e) {
        e.printStackTrace();
    }
}

public static GameData loadGame(File file) {
    try (Scanner scanner = new Scanner(file)) {
        scanner.nextLine();
        int level = Integer.parseInt(scanner.nextLine());
        int score = Integer.parseInt(scanner.nextLine());
        int lives = Integer.parseInt(scanner.nextLine());
        float catX = Float.parseFloat(scanner.nextLine());
        float catY = Float.parseFloat(scanner.nextLine());
        return new GameData(level, score, lives, catX, catY);
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    return null;
}
//

I used AI to help me build saving and loading for my game so players could keep their progress. I didn’t know a
simple way to save the level, player stats, and position into a file.

Prompt:
"How can I save and load a simple game state (level, score, player position) in Java using a text file?"

What I did:
AI suggested writing each important value to a new line with PrintWriter, and reading them back in the same order using Scanner.
I made a GameState class using this advice and connected it to my main menu so the player could load their game.

How AI Helped Me Learn:
It showed me a clean simple way to save player progress, and helped me practice working with files and text in Java.


(5)

//
@Override
public void mousePressed(MouseEvent e) {
    isMouseDown = true;
    mousePressTime = System.currentTimeMillis();

    Timer chargeDelayTimer = new Timer((int) CHARGE_DELAY, ev -> {
        if (isMouseDown && cat.getNubellaCount() > 0) {
            cat.startChargingNubella();
        }
    });
    chargeDelayTimer.setRepeats(false);
    chargeDelayTimer.start();
}

@Override
public void mouseReleased(MouseEvent e) {
    isMouseDown = false;

    long heldTime = System.currentTimeMillis() - mousePressTime;
    if (heldTime >= CHARGE_DELAY) {
        cat.releaseNubella();
    }
}
//
I used AI to help me add a "hold-to-charge" mechanic for firing the Nubella projectile instead of just a normal click.
I wanted the player to press and hold the mouse button for a short moment to charge up before releasing the shot.

Prompt:
"How do I detect if the mouse button was held down for a certain time in Java Swing?"

What I did:
AI suggested recording the time when the mouse was pressed (mousePressTime) and checking the difference when the mouse was
released. It also recommended using a short Timer to start charging after a delay if the button was still held down.
I set it up with a 200ms delay so charging feels smooth without being too slow.

How AI Helped Me Learn:
It taught me how to combine mouse input and timing to make a move feel responsive, instead of just reacting instantly to clicks.


